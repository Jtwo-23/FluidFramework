# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# build-docker-service template to build services docker container

parameters:
- name: buildDirectory
  type: string

- name: containerName
  type: string

- name: pack
  type: boolean
  default: false

- name: lint
  type: boolean
  default: false

- name: test
  type: string
  default:

- name: docs
  type: boolean
  default: false

- name: containerBaseDir
  type: string
  default: /home/node/server

- name: buildNumberInPatch
  type: string
  default: true

- name: setVersion
  type: boolean
  default: true

- name: releaseKind
  type: string
  default: docker

- name: tagName
  type: string
  default:

- name: isReleaseGroup
  type: boolean
  default: false

- name: pool
  type: string
  default: Small-1ES

- name: buildToolsVersionToInstall
  type: string
  default: repo

- name: packageManager
  type: string
  default: npm

- name: packageManagerInstallCommand
  type: string
  default: 'npm ci --unsafe-perm'

# The semver range constraint to use for interdependencies; that is, dependencies on other packages within the release
# group
- name: interdependencyRange
  type: string
  default: "^"

# A list of scripts that execute checks of the release group, e.g. prettier, syncpack, etc. These will be run serially
# in a pipeline stage separate from the build stage.
- name: checks
  type: object
  default: []

# Any additional build arguments to pass to the docker build command.
- name: additionalBuildArguments
  type: string
  default: ""

# If the build is running for a test branch
- name: testBuild
  type: boolean
  default: false

# Whether the docker image should be pushed to our internal Azure Container Registry
- name: shouldPushDockerImage
  type: boolean
  default: false

# Whether the docker image should be released officially
- name: shouldReleaseDockerImage
  type: boolean
  default: false

# Whether npm packages should be published
- name: shouldPublishNpmPackages
  type: boolean
  default: false

trigger: none

resources:
  repositories:
  - repository: m365Pipelines
    type: git
    name: 1ESPipelineTemplates/M365GPT
    ref: refs/tags/release
extends:
  template: v1/M365.Official.PipelineTemplate.yml@m365Pipelines
  parameters:
    pool:
      name: Small-1ES
      os: linux
    sdl:
      arrow:
        # This is the service connection for the Arrow Service Connection in FluidFramework Azure DevOps organization
        # Currently we want to use different names for internal and public builds for Arrow Service Connection
        ${{ if eq(variables['System.TeamProject'], 'internal') }}:
          serviceConnection: Arrow_FluidFramework_internal
        ${{ else }}:
          serviceConnection: Arrow_FluidFramework_public
      sourceAnalysisPool:
        name: Azure-Pipelines-1ESPT-ExDShared
        image: windows-2022
        os: windows
    customBuildTags:
      - ES365AIMigrationTooling
    stages:
    - ${{ if ne(convertToJson(parameters.checks), '[]') }}:
      - template: /tools/pipelines/templates/1ES/include-policy-check.yml@self
        parameters:
          buildDirectory: ${{ parameters.buildDirectory }}
          checks: ${{ parameters.checks }}
    - stage: build
      displayName: Build Stage
      dependsOn: [] # this stage doesn't depend on preceding stage
      variables:
        - ${{ if eq(parameters.testBuild, true) }}:
          - name: buildContainerName
            value: test/${{ parameters.containerName }}
        - ${{ else }}:
          - name: buildContainerName
            value: build/${{ parameters.containerName }}
        - name: containerTagSuffix
          value: $[ format('0.0.{0}', variables['Build.BuildNumber']) ]
        - name: baseContainerTag
          value: base:$(containerTagSuffix)
        - ${{ if eq(parameters.shouldPushDockerImage, false) }}:
          - name: containerTag
            value: $(buildContainerName):$(containerTagSuffix)
        - ${{ else }}:
          - name: containerTag
            value: $(containerRegistryUrl)/$(buildContainerName):$(containerTagSuffix)
          - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
            - name: latestContainerTagSuffix
              value: latest
            - name: latestContainerTag
              value: $(containerRegistryUrl)/$(buildContainerName):$(latestContainerTagSuffix)
          - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/next') }}:
            - name: latestContainerTagSuffix
              value: next
            - name: latestContainerTag
              value: $(containerRegistryUrl)/$(buildContainerName):$(latestContainerTagSuffix)
        # tag the git repo when we published the docker image if the releaseKind is docker,
        # otherwise tag with the publishing the packages (where the releaseKind is both or npm)
        - ${{ if ne(parameters.releaseKind, 'docker') }}:
          - name: tagNameOnReleaseImage
            value:
        - ${{ if eq(parameters.releaseKind, 'docker') }}:
          - name: tagNameOnReleaseImage
            value: ${{ parameters.tagName }}
      jobs:
      - job: build
        displayName: Build Container - ${{ parameters.containerName }}
        variables:
          buildBase: ${{ or(ne(parameters.test, ''), or(eq(parameters.pack, true), or(eq(parameters.lint, true), eq(parameters.docs, true)))) }}
          testCoverage: ${{ and(eq(parameters.test, 'ci:test'), ne(variables['Build.Reason'], 'PullRequest')) }}
          releaseBuildVar: $[variables.releaseBuild]
        steps:
        # Setup
        - checkout: self
          clean: true
          lfs: false
          submodules: false

        - task: Bash@3
          displayName: Parameters
          inputs:
            targetType: 'inline'
            workingDirectory: ${{ parameters.buildDirectory }}
            script: |
              # Show all task group conditions
              echo "
              Pipeline Variables:
                releaseBuild=$(releaseBuildVar)
                sourceBranch=${{ variables['Build.SourceBranch'] }}

              Tasks Parameters:
                Lint=${{ parameters.lint }}
                Test=${{ parameters.test }}

              Other parameters:
                shouldPushDockerImage=${{ parameters.shouldPushDockerImage }}
                testBuild=${{ parameters.testBuild }}
                shouldReleaseDockerImage=${{ parameters.shouldReleaseDockerImage }}
                shouldPublishNpmPackages=${{ parameters.shouldPublishNpmPackages }}

              Computed variables:
                shouldPublish=$(shouldPublish)
                canRelease=$(canRelease)
                interdependencyRange='${{ parameters.interdependencyRange }}'

                release=$(release)

                containerTagSuffix=$(containerTagSuffix)
                containerRegistryUrl=$(containerRegistryUrl)
                containerRegistryConnection=$(containerRegistryConnection)
                containerTag=$(containerTag)
                buildContainerName=$(buildContainerName)
              "

              if [[ "$(release)" == "release" ]]; then
                if [[ "$(canRelease)" == "False" ]]; then
                  echo "##vso[task.logissue type=error]Invalid branch ${{ variables['Build.SourceBranch'] }} for release"
                  exit -1;
                fi

                if [ -f "lerna.json" ]; then
                  grep -e fluid.*[0-9]-[0-9] `find packages -name 'package.json'`
                else
                  grep -e fluid.*[0-9]-[0-9] `find . -name 'package.json'`
                fi

                if [[ $? == 0 ]]; then
                  echo "##vso[task.logissue type=error]Release shouldn't contain prerelease dependencies"
                  exit -1;
                fi
              fi

              if [[ "$(release)" == "prerelease" ]]; then
                if [[ "${{ parameters.buildNumberInPatch }}" == "true" ]]; then
                  echo "##vso[task.logissue type=error] Prerelease not allow for builds that put build number as the patch version"
                  exit -1;
                fi
              fi

              if [[ "$(release)" != "none" ]] && [[ "$(release)" != "" ]]; then
                if [[ "${{ parameters.shouldPushDockerImage }}" != "True" ]]; then
                  echo "##vso[task.logissue type=error]'$(release)' is set but image is not pushed. Either the branch doesn't default to push image or it is skipped."
                  exit -1;
                fi

                if [[ "$(releaseImage)" != "True" ]]; then
                  echo "##vso[task.logissue type=error]'$(release)' is set but pipeline isn't declared to allow release image."
                  exit -1;
                fi
              fi

        # for npm ci in component detection and set version
        - template: /tools/pipelines/templates/1ES/include-use-node-version.yml@self

        # Component detection
        - ${{ if eq(parameters.shouldPublishNpmPackages, true) }}:
          - template: /tools/pipelines/templates/1ES/include-generate-notice-steps.yml@self
            parameters:
              buildDirectory: ${{ parameters.buildDirectory }}
              requireNotice: ${{ parameters.shouldReleaseDockerImage }}

        - ${{ if eq(parameters.packageManager, 'pnpm') }}:
          - template: /tools/pipelines/templates/1ES/include-install-pnpm.yml@self
            parameters:
              buildDirectory: ${{ parameters.buildDirectory }}

        # Set version
        - ${{ if eq(parameters.setVersion, true) }}:
          - task: Bash@3
            displayName: Install dependencies
            inputs:
              targetType: 'inline'
              workingDirectory: ${{ parameters.buildDirectory }}
              script: |
                ${{ parameters.packageManagerInstallCommand }}

          - template: /tools/pipelines/templates/1ES/include-set-package-version.yml@self
            parameters:
              buildDirectory: ${{ parameters.buildDirectory }}
              buildNumberInPatch: ${{ parameters.buildNumberInPatch }}
              buildToolsVersionToInstall: ${{ parameters.buildToolsVersionToInstall }}
              interdependencyRange: ${{ parameters.interdependencyRange }}
              tagName: ${{ parameters.tagName }}
        - ${{ if eq(parameters.setVersion, false) }}:
          - task: Bash@3
            name: SetVersion
            displayName: Set Package version
            inputs:
              targetType: 'inline'
              script: |
                echo "$(containerTagSuffix)"
                echo "##vso[task.setvariable variable=version;isOutput=true]$(containerTagSuffix)"

        - ${{ if eq(variables.buildBase, true) }}:
          # Build - Base
          - task: 1ES.BuildContainerImage@1
            displayName: Docker Build - base
            inputs:
              dockerfile: ${{ parameters.buildDirectory }}/Dockerfile
              context: ${{ parameters.buildDirectory }}
              image: $(containerRegistryUrl)/base:$(containerTagSuffix)
              buildArguments: --target base ${{ parameters.additionalBuildArguments }}
              useBuildKit: true
              enableNetwork: true

          # Pack
          - ${{ if eq(parameters.pack, true) }}:
            # Need to create folders outside the docker container; if it creates them, the permissions will be wrong and
            # we won't be able to write to them from outside the container when generating the lists of packages below.
            - task: Bash@3
              displayName: Create folder for pack artifact
              inputs:
                targetType: 'inline'
                script: |
                  mkdir -p $(Build.ArtifactStagingDirectory)/pack

            - task: Docker@1
              displayName: Pack
              inputs:
                command: run
                arguments: '-v $(Build.ArtifactStagingDirectory)/pack/scoped:/usr/src/pack -t $(baseContainerTag) pnpm lerna exec --no-private -- mv `npm pack` /usr/src/pack'

            # Generating package lists manually because using scripts/pack-packages.sh (like build-npm-package.yml does)
            # inside the Docker container is proving problematic.
            # See https://github.com/microsoft/FluidFramework/pull/18445 for details.
            - task: Bash@3
              displayName: Generate package lists
              env:
                RELEASE_GROUP: ${{ parameters.tagName }}
                STAGING_PATH: $(Build.ArtifactStagingDirectory)
              inputs:
                targetType: 'inline'
                workingDirectory: ${{ parameters.buildDirectory }}
                script: |
                  flub list --no-private --releaseGroup $RELEASE_GROUP --tarball --feed public > $STAGING_PATH/pack/packagePublishOrder-public.txt
                  flub list --no-private --releaseGroup $RELEASE_GROUP --tarball --feed internal-build > $STAGING_PATH/pack/packagePublishOrder-internal-build.txt
                  flub list --no-private --releaseGroup $RELEASE_GROUP --tarball --feed internal-dev > $STAGING_PATH/pack/packagePublishOrder-internal-dev.txt
                  flub list --no-private --releaseGroup $RELEASE_GROUP --tarball --feed internal-test > $STAGING_PATH/pack/packagePublishOrder-internal-test.txt

          # Note: The publishing steps have been moved to the output section at the bottom of this file after converting to the Microsoft 1ES pipeline template

          # Lint
          - ${{ if eq(parameters.lint, true) }}:
            - task: Docker@1
              displayName: npm run lint
              inputs:
                command: run
                arguments: '-t $(baseContainerTag) npm run lint'

          # Test
          - ${{ if ne(parameters.test, '') }}:
            # Test - No coverage
            - ${{ if ne(variables.testCoverage, true) }}:
              - task: Docker@1
                displayName: npm run ${{ parameters.test }}
                inputs:
                  command: run
                  arguments: '--user root -v $(Build.ArtifactStagingDirectory)/${{ parameters.buildDirectory }}/nyc:${{ parameters.containerBaseDir }}/nyc -t $(baseContainerTag) npm run ${{ parameters.test }}'

            # Test - With coverage
            - ${{ if eq(variables.testCoverage, true) }}:
              - task: Docker@1
                displayName: npm run ci:test:coverage
                inputs:
                  command: run
                  arguments: '--user root -v $(Build.ArtifactStagingDirectory)/${{ parameters.buildDirectory }}/nyc:${{ parameters.containerBaseDir }}/nyc -t $(baseContainerTag) npm run ci:test:coverage'

              - task: PublishCodeCoverageResults@1
                displayName: Publish Code Coverage
                inputs:
                  codeCoverageTool: Cobertura
                  summaryFileLocation: '$(Build.ArtifactStagingDirectory)/${{ parameters.buildDirectory }}/nyc/**/report/cobertura-coverage.xml'
                  reportDirectory: '$(Build.ArtifactStagingDirectory)/${{ parameters.buildDirectory }}/nyc/**/report'
                  failIfCoverageEmpty: true
                condition: succeededOrFailed()

            # Test - Upload Results
            - task: PublishTestResults@2
              displayName: Publish Test Results
              inputs:
                testResultsFormat: 'JUnit'
                testResultsFiles: '**/*junit-report.xml'
                searchFolder: $(Build.ArtifactStagingDirectory)/${{ parameters.buildDirectory }}/nyc
                mergeTestResults: true
              condition: succeededOrFailed()

          # Docs
          - ${{ if eq(parameters.docs, true) }}:
            - task: Docker@1
              displayName: npm run ci:build:docs
              inputs:
                command: run
                arguments: '--user root -v $(Build.ArtifactStagingDirectory)/_api-extractor-temp:/usr/src/server/_api-extractor-temp -t $(baseContainerTag) npm run ci:build:docs'

          # Note: The doc publishing step has been moved to the output section at the bottom of this file after converting to the Microsoft 1ES pipeline template

        # Build
        - task: 1ES.BuildContainerImage@1
          displayName: Docker Build - $(containerTag)
          inputs:
            dockerfile: ${{ parameters.buildDirectory }}/Dockerfile
            context: ${{ parameters.buildDirectory }}
            image: $(containerTag)
            buildArguments: ${{ parameters.additionalBuildArguments }}
            useBuildKit: true
            enableNetwork: true

        # Push
        - ${{ if eq(parameters.shouldPushDockerImage, true) }}:
          - task: 1ES.PushContainerImage@1
            displayName: Docker Push - $(containerTag)
            inputs:
              image: $(containerTag)
          - task: 1ES.PushContainerImage@1
            displayName: Docker Push - $(latestContainerTag)
            condition: ne(variables.latestContainerTag, '')
            inputs:
              image: $(containerTag)
              remoteImage: $(latestContainerTag)

        templateContext:
          ${{ if eq(parameters.shouldPushDockerImage, true) }}:
            authenticatedContainerRegistries:
            # $(containerRegistryConnection) comes from the container-registry-info variable group and needs to be
            # specified as a runtime variable (variables from variable groups apparently are never available "statically"
            # at parse/compile time, so can't be used with template-expression syntax ( '${{ }}' )).
            - serviceConnection: $(containerRegistryConnection)
          outputs:
          - ${{ if and(eq(variables.buildBase, true), eq(parameters.pack, true)) }}:
            - output: pipelineArtifact
              displayName: 'Publish Artifact - pack'
              targetPath: '$(Build.ArtifactStagingDirectory)/pack'
              artifactName: pack
              publishLocation: 'pipeline'
          - ${{ if and(eq(variables.buildBase, true), eq(parameters.docs, true)) }}:
            - output: pipelineArtifact
              displayName: 'Docs: Publish Artifact'
              targetPath: '$(Build.ArtifactStagingDirectory)/_api-extractor-temp'
              artifactName: _api-extractor-temp
              publishLocation: 'pipeline'

    # Publish stage
    - ${{ if and(eq(parameters.shouldPublishNpmPackages, true), ne(parameters.releaseKind, 'docker')) }}:
      - template: /tools/pipelines/templates/1ES/include-publish-npm-package.yml@self
        parameters:
          tagName: ${{ parameters.tagName }}
          isReleaseGroup: ${{ parameters.isReleaseGroup }}

    - ${{ if eq(parameters.shouldReleaseDockerImage, true) }}:
      - template: /tools/pipelines/templates/1ES/include-publish-docker-service.yml@self
        parameters:
          containerRegistry: $(containerRegistryConnection)
          containerTag: $(containerTag)
          containerRegistryUrl: $(containerRegistryUrl)
          containerName: ${{ parameters.containerName }}
          tagName: $(tagNameOnReleaseImage)
